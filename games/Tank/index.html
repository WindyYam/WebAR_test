<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5 Tank Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            user-select: none; /* Prevents text selection */
            -webkit-user-select: none; /* Chrome, Safari, and Edge */
            -ms-user-select: none; /* Internet Explorer */
            -moz-user-select: none; /* Firefox */
        }
        canvas {
            display: block;
            background-color: #000;
        }
        .virtual-buttons {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        .button {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="virtual-buttons">
        <div class="button" id="up">â¬†</div>
        <div class="button" id="left">â¬…</div>
        <div class="button" id="right">âž¡</div>
        <div class="button" id="down">â¬‡</div>
        <div class="button" id="fire">ðŸ”¥</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const TILE_SIZE = 40;
        const TANK_SIZE = TILE_SIZE * 0.8;
        const BULLET_SPEED = 2;
        const ENEMY_COUNT = 40;
        const PLAYER_SPEED = 1;
        const ENERMY_SPEED = 1;
        const keys = {};

        const playerTank = {
            x: canvas.width / 2 - TANK_SIZE / 2,
            y: canvas.height - TILE_SIZE * 2,
            size: TANK_SIZE,
            color: 'green',
            isEnemy: false,
            direction: 'up',
            health: 3,
            id: 'player'
        };

        const game = {
            tanks: [],
            bullets: [],
            blocks: [],
            explosions: [],
            base: { x: canvas.width / 2, y: canvas.height - TILE_SIZE, size: TILE_SIZE },
            win: false,
            lose: false,
            init() {
                this.tanks = [];
                this.bullets = [];
                this.blocks = [];
                this.explosions = [];
                this.win = false;
                this.lose = false;
                for (let i = 0; i < 100; i++) {
                    this.blocks.push({
                        x: Math.random() * (canvas.width - TILE_SIZE),
                        y: Math.random() * (canvas.height - TILE_SIZE * 2),
                        size: TILE_SIZE,
                        destroyable: true,
                    });
                }

                for (let i = 0; i < ENEMY_COUNT; i++) {
                    this.tanks.push({
                        x: Math.random() * (canvas.width - TANK_SIZE),
                        y: Math.random() * (canvas.height / 2 - TANK_SIZE),
                        size: TANK_SIZE,
                        color: 'red',
                        isEnemy: true,
                        direction: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)],
                        shootCooldown: Math.random() * 100 + 50,
                        health: 1,
                        id: `enemy-${i}`
                    });
                }
                playerTank.health = 3;
                this.tanks.push(playerTank);
            },
        };

        function updateGame() {
            if ((game.win == false) && (game.tanks.filter(t => t.isEnemy).length === 0)){ 
                game.win = true;
                setTimeout(()=>{game.init()}, 1000);
            }
            if ((game.lose == false) && (playerTank.health <= 0 || game.base.destroyed)){
                game.lose = true;
                setTimeout(()=>{game.init()}, 1000);
            }

            if (keys['ArrowUp'] || keys['up']) {
                playerTank.y -= PLAYER_SPEED;
                playerTank.direction = 'up';
            }
            if (keys['ArrowDown'] || keys['down']) {
                playerTank.y += PLAYER_SPEED;
                playerTank.direction = 'down';
            }
            if (keys['ArrowLeft'] || keys['left']) {
                playerTank.x -= PLAYER_SPEED;
                playerTank.direction = 'left';
            }
            if (keys['ArrowRight'] || keys['right']) {
                playerTank.x += PLAYER_SPEED;
                playerTank.direction = 'right';
            }

            if (keys[' ']) {
                keys[' '] = false;
                fireBullet(playerTank);
            }

            playerTank.x = Math.max(0, Math.min(canvas.width - TANK_SIZE, playerTank.x));
            playerTank.y = Math.max(0, Math.min(canvas.height - TANK_SIZE, playerTank.y));

            game.tanks.forEach((tank, i) => {
                if (tank.isEnemy) {
                    if (Math.random() < 0.02) {
                        tank.direction = ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)];
                    }

                    switch (tank.direction) {
                        case 'up':
                            tank.y -= ENERMY_SPEED;
                            break;
                        case 'down':
                            tank.y += ENERMY_SPEED;
                            break;
                        case 'left':
                            tank.x -= ENERMY_SPEED;
                            break;
                        case 'right':
                            tank.x += ENERMY_SPEED;
                            break;
                    }

                    tank.x = Math.max(0, Math.min(canvas.width - TANK_SIZE, tank.x));
                    tank.y = Math.max(0, Math.min(canvas.height - TANK_SIZE, tank.y));

                    tank.shootCooldown--;
                    if (tank.shootCooldown <= 0) {
                        fireBullet(tank);
                        tank.shootCooldown = Math.random() * 100 + 50;
                    }
                }
            });

            game.bullets.forEach((bullet, index) => {
                switch (bullet.direction) {
                    case 'up':
                        bullet.y -= BULLET_SPEED;
                        break;
                    case 'down':
                        bullet.y += BULLET_SPEED;
                        break;
                    case 'left':
                        bullet.x -= BULLET_SPEED;
                        break;
                    case 'right':
                        bullet.x += BULLET_SPEED;
                        break;
                }

                if (bullet.x < 0 || bullet.y < 0 || bullet.x > canvas.width || bullet.y > canvas.height) {
                    game.bullets.splice(index, 1);
                }

                game.blocks.forEach((block, blockIndex) => {
                    if (
                        bullet.x < block.x + block.size &&
                        bullet.x + bullet.size > block.x &&
                        bullet.y < block.y + block.size &&
                        bullet.y + bullet.size > block.y
                    ) {
                        game.bullets.splice(index, 1);
                        if (block.destroyable) {
                            game.blocks.splice(blockIndex, 1);
                        }
                    }
                });

                game.tanks.forEach((tank, tankIndex) => {
                    if (
                        bullet.x < tank.x + tank.size &&
                        bullet.x + bullet.size > tank.x &&
                        bullet.y < tank.y + tank.size &&
                        bullet.y + bullet.size > tank.y &&
                        bullet.shooterId !== tank.id
                    ) {
                        game.bullets.splice(index, 1);
                        tank.health--;
                        if (tank.health <= 0) {
                            explodeTank(tank);
                            game.tanks.splice(tankIndex, 1);
                        }
                    }
                });
            });

            game.explosions = game.explosions.filter((explosion) => explosion.timer > 0);
        }

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (game.win) {
                ctx.fillStyle = 'white';
                ctx.font = '48px Arial';
                ctx.fillText('You Win!', canvas.width / 2 - 100, canvas.height / 2);
            }

            if (game.lose) {
                ctx.fillStyle = 'red';
                ctx.font = '48px Arial';
                ctx.fillText('Game Over!', canvas.width / 2 - 120, canvas.height / 2);
            }

            ctx.fillStyle = 'blue';
            ctx.fillRect(game.base.x, game.base.y, game.base.size, game.base.size);

            game.tanks.forEach((tank) => {
                drawTank(tank);
            });

            game.bullets.forEach((bullet) => {
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.size, bullet.size);
            });

            game.blocks.forEach((block) => {
                ctx.fillStyle = block.destroyable ? 'gray' : 'darkgray';
                ctx.fillRect(block.x, block.y, block.size, block.size);
            });

            game.explosions.forEach((explosion) => {
                ctx.fillStyle = `rgba(255, 165, 0, ${explosion.timer / 20})`;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.size, 0, Math.PI * 2);
                ctx.fill();
                explosion.timer--;
            });
        }

        function drawTank(tank) {
            ctx.fillStyle = tank.color;
            ctx.fillRect(tank.x, tank.y, tank.size, tank.size);
            ctx.fillStyle = 'black';
            if (tank.direction === 'up' || tank.direction === 'down') {
                ctx.fillRect(tank.x + tank.size / 2 - 5, tank.y, 10, tank.size);
            } else {
                ctx.fillRect(tank.x, tank.y + tank.size / 2 - 5, tank.size, 10);
            }
            ctx.fillStyle = tank.color;
            if (tank.direction === 'up'){
                ctx.fillRect(tank.x + tank.size / 2 - 5, tank.y - tank.size / 2, 10, tank.size);
            }
            else if (tank.direction === 'down'){
                ctx.fillRect(tank.x + tank.size / 2 - 5, tank.y + tank.size / 2, 10, tank.size);
            }
            else if (tank.direction === 'left'){
                ctx.fillRect(tank.x - tank.size / 2, tank.y + tank.size / 2 - 5, tank.size, 10);
            }
            else{
                ctx.fillRect(tank.x + tank.size / 2, tank.y + tank.size / 2 - 5, tank.size, 10);
            }
        }

        function fireBullet(tank) {
            game.bullets.push({
                x: tank.x + tank.size / 2 - 5,
                y: tank.y + tank.size / 2 - 5,
                size: 10,
                color: tank.isEnemy ? 'red' : 'yellow',
                direction: tank.direction,
                shooterId: tank.id
            });
        }

        function explodeTank(tank) {
            game.explosions.push({
                x: tank.x + tank.size / 2,
                y: tank.y + tank.size / 2,
                size: 30,
                timer: 20,
            });
        }

        window.addEventListener('keydown', (e) => (keys[e.key] = true));
        window.addEventListener('keyup', (e) => (keys[e.key] = false));

        document.getElementById('up').addEventListener('pointerdown', () => {keys['up'] = true, keys['down'] = false, keys['left'] = false, keys['right'] = false});
        document.getElementById('up').addEventListener('pointerup', () => (keys['up'] = false));
        document.getElementById('down').addEventListener('pointerdown', () => {keys['up'] = false, keys['down'] = true, keys['left'] = false, keys['right'] = false});
        document.getElementById('down').addEventListener('pointerup', () => (keys['down'] = false));
        document.getElementById('left').addEventListener('pointerdown', () => {keys['up'] = false, keys['down'] = false, keys['left'] = true, keys['right'] = false});
        document.getElementById('left').addEventListener('pointerup', () => (keys['left'] = false));
        document.getElementById('right').addEventListener('pointerdown', () => {keys['up'] = false, keys['down'] = false, keys['left'] = false, keys['right'] = true});
        document.getElementById('right').addEventListener('pointerup', () => (keys['right'] = false));
        document.getElementById('fire').addEventListener('pointerdown', () => fireBullet(playerTank));

        game.init();
        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
